# 오늘 배운거

### 배열
- 배열안에는 동일한 데이터 타입만 저장할 수 있다. (파이썬은 다른것도 저장 가능)
- 배열의 변수명은 복수형으로 쓴다. (score -> scores)
- int[] arrs = new int[10]; new가 자동으로 배열을 0으로 초기화 시켜준다.
- 초기화 할때 나눠서 쓰면 에러가 난다.
(Ex) int[] scores2 = {};
		   scores2 = {10,12,11,14,15};
- 왜냐하면 선언할때 배열의 크기를 안 정했기 때문이다.
- 원소가 원시타입인 경우 선언하면 연속된 주소에 할당된다. (int형이면 4byte씩 차지한다.)
- 참조타입인 경우 주소를 저장하고 있는데 8byte씩 사용한다. 이는 64bit 체제라서 그럼 32bit 체제는 4byte씩 차지한다.
- 배열을 print 하면 이상한 숫자가 뜨는데 이는 객체의 아이디를 hash string으로 바꾼 것이다. addressOf(배열) 하면 실제 배열의 주소가 출력된다.
- hashcode는 중복이 되면 안되기 때문에 소수(약수가 1과 자기자신)만 사용한다.

### 이차원배열
- 개발자가 편하라고 만든 개념, 실제로는 일차원으로 저장되어 있다.
- 행끼리 묶어서 메모리에 저장, 각 행의 첫번째 주소만 저장되어있다. 왜냐하면 배열은 4byte씩 연속적으로 저장되어 있기 때문이다.
- 참조타입은 조금 다르다. String Pool의 주소를 다 알고 있는 배열의 주소를 저장한다. 

### row-major vs column-major
- 보통 row 기준으로 저장되어 있다. 그런데 평소 이용할때는 column 단위의 데이터 출력을 많이함.
- 그래서 column major로 구현하면 속도가 빠를 수 있다.
- row-major : C/C++, Pascal, Python
- column-major : Fortran, Julia, R, Matlab

### 배열의 비교
- 원소를 반복하면서 비교를 해야한다.
- Arrays.equals()도 가능

### 배열의 복사
- 그냥 복사하면 주소가 복사 된다. 주소가 복사가 되면, 원본의 주소가 변경되는 문제가 발생
- for문으로 각각의 원소를 복사해야한다.

### 열거형
- 서로 관련있는 상수끼리 열거하여 정의하는 것
- 클래스처럼 사용할 수 있다.

### 함수
- 코드 가독성 : 보통 함수는 기능을 잘 보여주기 위해 동사 + 목적어 형태로 작성
- (ex) countLetter(), calculateAverage(), ...
- 특징
	- 반환값이 없거나 1개
	- 2개 이상은 객체나 배열로 묶기

### 함수 오버로딩(overload)
- 함수의 이름은 같으나 매개변수에 따라 다른 함수가 호출됨
- 재정의 한게 아니라 복제품 여러개 만든 느낌
(Ex)
	public static int a(){}
	public static int a(int x, int y){}
- a() 만 호출하면 위에꺼가, a(1,2)을 호출하면 밑에꺼가 호출된다.
- 매개변수 개수, 순서, 타입 중 하나가 다르면 다르다고 판단

### 함수 가변인자
- public void main(String[] args)
- public void main(String... args)
- 위 예제 처럼 인자의 개수를 알지 못할 때 가변인자로 정의 가능
- 배열로 변화해서 컴파일

### 이름 명명법
- 함수 호출 수동태를 생각하면 된다. (...?)

### 재귀함수
- java에서는 사용하는 일이 잘 없는데, 알고리즘 문제에서 굉장히 많이 나온다. 
- 종료구문이 반드시 필요하다. (무한루프에 빠짐)

### 이슈 트래킹
- 자바에서는 call by reference가 없다.
- call by reference란? 주로 c++에만 존재함.다른 언어에는 참조자라는 개념이 없다. 
- 참조자란? 변수의 별명 같은 것
	- int& a = b; ( a의 주소와 b의 주소가 같음)
- call by value가 두가지로 나뉨
	- value가 참조타입인 경우
	- value가 원시타입인 경우
	- value에 address가 올 수는 있다. 그렇다고 해서 참조자라는 것은 아님 

