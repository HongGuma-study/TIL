# 오늘 배운거

### java 개요
- 제임스고슬링이 개발한 언어이다. 
- 이 아저씨 살아있고 MS에서 근무중
- 객체에 가까운 언어를 만들고 싶어 했고 커피를 좋아해서 이름이 java가 됨

### java특징
- 객체지향 프로그래밍 언어
- 컴파일된 코드는 어떤 플랫폼(OS)에서도 실행이 가능하다.

### java 버전
- 6,8,11 : 회사에서 많이 쓰는 버전
- 8 버전에서 아주 큰 문법의 변화가 일어 났다. 그래서 8을 기점으로 java가 나뉨
- LTS는 계속 개선이 되는 버전

### kotiln이 나온 이유
kotiln은 그냥 구글에서 개발한 언어 인줄 알았는데 
유료화된 java에 대항하기 위해 나온 언어인줄 몰랐다.
어쩐지 java랑 비슷하면서 쓰기 더 편하더라!

### SDK 약자
- Software Development Kit 라는 뜻이었다. 이것도 처음 알았다!

### 컴파일
- 컴파일은 고급어에서 저급어로 변환해주는 과정이다. 컴퓨터가 알아 들을 수 있게 처리해주는 작업이다
- 컴파일을 거쳐서 생긴게 바이트코드 이다. (바이트코드로 만들어지면서 최적화 된다.)
- 바이트코드는 OS마다 다 달라진다.

### 리터럴(literal)
- 데이터 값 자체
- 주로 왼쪽에 있는 항
- 근데 거의 안쓰는 표현이다. 

### 실수 표현하기
- 소수점을 영어로 floating-point라고 한다. 그래서 실수의 자료형이 float 인것!
- 실수의 표현은 소수점 뒷자리의 숫자가 많이 표현될 수록 정확도가 올라간다. 그래서 뒷자리에 비트를 많이 할당하기 위해 부동소수점을 사용하는 것이다.
- 부동소수점의 오차 : 소수점이 너무 길어지면 오차가 생길 가능성이 커진다. ( 32bit를 넘으면 부정확해진다. )
- 실수를 비교할때는 1.12331241455 == 1.12331241455 라고 비교하면 안된다. 1.12331241515-1.23151516 > 0 두 수의 차가 0이상인지 0이하인지 이런식으로만 비교해야 한다.

### ASCII code
- 안 외워도 된당. 그냥 'a', 'A'가 얼마인지만 상식 수준으로 알면 된다.
- java에서는 유니코드를 채택함

### 변수(variables)
- 값을 저장하는 저장공간.
- 변수에 담긴 값은 언제든지 변경이 가능하다~
- 변수명은 반드시 의미가 있을 것. 의미 없이 a, chch, 이런식으로 사용하면 안된다.(ex)boolean isMember, int avg, ...
- numberOfStudent 처럼 알아 볼 수 있게 선언 할 것. nos 이런식으로 본인만 아는 함축어 쓰면 안된다.
- 변수명에 띄어쓰기 불가. Snake case(`_`)를 쓰거나 Camal case를 쓰거나 Kebeb case(`-`)를 쓰던지 (파이썬이나 C는 Snake case를 쓰고 java에서는 Camel case를 사용한다. Kebeb case는 URL같은 주소에 자주 사용한다.)
- 변수명 정할때 구글에 java coding style 검색해서 해당 자료 참고하면 좋다. 
- 변수는 초기화 해서 사용한다. 
<예제>
int num = 10;
char ch = 'A';

### 상수
- final 이라는 예약어를 사용한다. 상수 은근 많이 쓰니 꼭 외워놓자!

### 변수의 종류
- 글로벌 변수 (global variable) : 메소드 밖에 선언된 변수
- 지역 변수 (local variable) : 메소드 블록 내에 선언된 변수, 메소드 실행이 끝나면 자동으로 사라짐
- 글로벌 변수는 블록 밖에서 선언해서 자유롭게 사용 가능
- 지역 변수는 블록 내에서 선언해서 블록 안에서만 사용 가능

### 증감연산자
i++과 ++i의 차이점은

<예제>
int num = 10;

System.out.println(num++);   //결과 10
System.out.println(num);     //결과 11
System.out.println(++num);   //결과 12
System.out.println(num);     //결과 12

처럼 나온다. 이렇게 나오는 이유는
num++ 은 println 한 이후에 +1 이되고
++num은 println 전에 +1을 하기 때문이다.


